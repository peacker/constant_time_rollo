#include "vector_space.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "bf.h"
#include "rollo-i-128_parameters.h"

/* Vector space functions */

int8_t uint16_t_is_zero(uint16_t a) {
    uint8_t result = 0;
    for (uint8_t i = 0; i < 16; ++i) {
        result = result | ((uint8_t) (a >> i) & 0x1u);
    }
    return 0x1u - result;
}

int8_t uint16_t_is_greater_than(uint16_t a, uint16_t b) {
    return ((int32_t) ((int32_t) (b - a) >> 16u)) & 0x1u;
}

/*
 * Returns the dimension of the vector space generated by the rows of matrix.
 * Reduces matrix to (right) systematic form.
 * The matrix is an array of binary field elements,
 * thus with m columns (where m is the binary field degree)
 */
int to_systematic_form(bf_element_t *matrix, uint16_t number_of_rows) {
// Only works for full rank matrices (systematic matrices)
// algorithm adapted from ClassicMcEliece (Bernstein - McBits)

    uint16_t number_of_columns = ROLLO_I_FINITE_FIELD_DEGREE;
    uint16_t min_nrows_ncols;

    uint16_t k;
    uint16_t row;
    bf_element_t mask;
    uint8_t is_systematic = 1;
    bf_element_t bit;
    bf_element_t checking_value;

    uint8_t verb = 0;

    // take minimum among ncols and nrows
//    bit = utils_is_greater_than_uint8_t(number_of_rows, number_of_columns);
    //bit = (uint8_t) (((number_of_columns - number_of_rows) >> 8u) & 0x1u);
    //min_nrows_ncols = number_of_rows*(1-bit) + number_of_columns*(bit);
    min_nrows_ncols = number_of_rows;

    if (verb) {
        printf("\nA = \n");
        bf_print_matrix_bin(matrix, number_of_rows);
    }

//    for (row = 0; row < number_of_columns; row++) {
    for (row = 0; row < number_of_rows; row++) {
//        printf("\nrow = %d\n", row);
        for (k = row + 1; k < number_of_rows; k++) {
            // if m[r][j] ^ m[k][j] != 0 then m[r] = m[r] + m[k]
//            bit = (uint8_t) ((uint8_t) ((uint8_t) (matrix[row] ^ matrix[k]) >> row) & 0x1u);
//            mask = -bit;
//            matrix[row] = (uint8_t) matrix[row] ^ (uint8_t) (matrix[k] & mask);

            // if m[r][j] ^ m[k][j] != 0 then m[r] = m[r] + m[k]
            bf_addition(&checking_value, &matrix[row], &matrix[k]);
            bf_compute_mask(&mask, &checking_value, row);
            bf_and(&mask, &matrix[k], &mask);
            bf_addition(&matrix[row], &matrix[row], &mask);
//            binary_field_conditional_assignment(&matrix[row], &checking_value, &matrix[k], row);

//            printf("\nk = %d\n", k);
//            printf("A = \n");
//            binary_vector_space_print_binary_matrix(matrix, number_of_rows);
        }

        if (uint8_t_ith_coefficient(&matrix[row], row) == 0) {
//            printf("Error! The matrix is not systematic!");
            is_systematic = 0;
        }
//        bit = (uint8_t) ((uint8_t) (matrix[row] >> row) & 0x1u);
//        is_systematic = is_systematic & bit;

        // if m[k][j] != 0 then m[k] = m[k] + m[r]
        // put 0 in column row and in the rows before row
        for (k = 0; k < row; k++) {
//            binary_field_conditional_assignment(&matrix[k], &matrix[k], &matrix[row], row);
            bf_compute_mask(&mask, &matrix[k], row);
            bf_and(&mask, &matrix[row], &mask);
            bf_addition(&matrix[k], &matrix[k], &mask);
        }

        // put 0 in column row and in the rows after row
        for (k = row + 1; k < number_of_rows; k++) {
//            binary_field_conditional_assignment(&matrix[k], &matrix[k], &matrix[row], row);
            bf_compute_mask(&mask, &matrix[k], row);
            bf_and(&mask, &matrix[row], &mask);
            bf_addition(&matrix[k], &matrix[k], &mask);

//            printf("\nk = %d\n", k);
//            printf("A = \n");
//            binary_vector_space_print_binary_matrix(matrix, number_of_rows);
        }
    }

    return is_systematic;
}

// reduces the matrix to reduced row echelon form using gaussian elimination
// returns the rank of the matrix
int to_reduced_row_echelon_form(bf_element_t *matrix, const uint16_t number_of_rows) {

    uint8_t number_of_columns = ROLLO_I_FINITE_FIELD_DEGREE;
    uint8_t bit1, bit2;
    bf_element_t mask1, mask2, mask3, mask2_and_mask3, tmp;
    uint16_t col;
    uint16_t row = 0;
    uint16_t i;
    uint8_t pivot_col_position[number_of_rows];
    uint8_t pivot_row_position[number_of_rows];
    uint8_t verb = 0;

    for (i = 0; i < number_of_rows; ++i) {
        pivot_col_position[i] = 0;
        pivot_row_position[i] = 0;
    }
    for (col = 0; col < number_of_columns; ++col) {
        for (i = 0; i < number_of_rows; ++i) {

            bf_compute_mask_inverse(&mask1, &matrix[row], col); // not is_zero(m[r,c])
            bf_compute_mask(&mask2, &matrix[i], col); // is_zero(m[i,c])
            bit1 = uint16_t_is_greater_than(i, row);
            bf_set_mask(&mask3, bit1);

            bf_and(&mask2_and_mask3, &mask2, &mask3);
            bf_and(&tmp, &mask2_and_mask3, &mask1);
            bf_and(&tmp, &matrix[i], &tmp);
            bf_addition(&matrix[row], &matrix[row], &tmp);

            bf_and(&tmp, &matrix[row], &mask2_and_mask3);
            bf_addition(&matrix[i], &matrix[i], &tmp);
        }

        bit1 = uint8_t_ith_coefficient(&matrix[row], col);
        pivot_col_position[row] = col*bit1;
        pivot_row_position[row] = row;
        bit1 = 0x1u - bit1;

        // check if row-number_of_rows is 0, i.e. if row reached the end of the matrix
        bit2 = uint16_t_is_zero(row ^ number_of_rows);

        // increase if the pivot is 1 and row has not reached the end of the matrix
        row = row + ((uint16_t) ((uint16_t) ((uint16_t) (bit1 & bit2) ^ bit1) ^ bit2) ^ 0x1u);
    }

    if (verb) {
        for (i = 0; i < number_of_rows; ++i) {
            printf("pivot_row_position[%d] = %d\n", i, pivot_row_position[i]);
            printf("pivot_col_position[%d] = %d\n", i, pivot_col_position[i]);
        }
        printf("m = \n");
        bf_print_matrix_bin(matrix, number_of_rows);
        printf("\n");
    }


    for  (uint8_t j = 0; j < number_of_rows; ++j) {
        for (i = 0; i < number_of_rows; ++i) {
            if (verb) {
                printf("\ncol = %d \n", pivot_col_position[j]);
                printf("m[%d] = ", i);
                bf_print_binary(&matrix[i]);
                printf("\n");
                printf("m[%d] = ", pivot_row_position[j]);
                bf_print_binary(&matrix[pivot_row_position[j]]);
                printf("\n");
                printf("(m[%d] >> col) & 0x1u = %d", i, uint8_t_ith_coefficient(&matrix[i], pivot_col_position[j]) );
                printf("\n");
                bf_addition(&tmp, &matrix[i], &matrix[pivot_row_position[j]]);
                printf("m[%d] = ", i);
                bf_print_binary(&tmp);
                printf("\n");
            }
//            if ((i < pivot_row_position[j]) && (((matrix[i].value >> pivot_col_position[j]) & 0x1u) == 1)) {
//                matrix[i].value = matrix[i].value ^ matrix[pivot_row_position[j]].value;
//            }
            bit1 = uint16_t_is_greater_than(pivot_row_position[j], i);
            bf_set_mask(&mask1, bit1);
            bf_and(&mask1, &mask1, &matrix[pivot_row_position[j]]);
            bit2 = uint8_t_ith_coefficient(&matrix[i], pivot_col_position[j]);
            bf_set_mask(&mask2, bit2);
            bf_and(&mask1, &mask1, &mask2);
            bf_addition(&matrix[i], &matrix[i], &mask1);
        }
    }

    return row;
}

// reduces the matrix to row echelon form using gaussian elimination
// returns the rank of the matrix
int to_row_echelon_form(bf_element_t *matrix, uint16_t number_of_rows) {

    uint8_t number_of_columns = ROLLO_I_FINITE_FIELD_DEGREE;
    uint8_t bit1, bit2;
    bf_element_t mask1, mask2, mask3, mask2_and_mask3, tmp;
    uint16_t col;
    uint16_t row = 0;
    uint16_t i;

    for (col = 0; col < number_of_columns; ++col) {
        for (i = 0; i < number_of_rows; ++i) {

            bf_compute_mask_inverse(&mask1, &matrix[row], col); // not is_zero(m[r,c])
            bf_compute_mask(&mask2, &matrix[i], col); // is_zero(m[i,c])
            bit1 = uint16_t_is_greater_than(i, row);
            bf_set_mask(&mask3, bit1);

            bf_and(&mask2_and_mask3, &mask2, &mask3);
            bf_and(&tmp, &mask2_and_mask3, &mask1);
            bf_and(&tmp, &matrix[i], &tmp);
            bf_addition(&matrix[row], &matrix[row], &tmp);

            bf_and(&tmp, &matrix[row], &mask2_and_mask3);
            bf_addition(&matrix[i], &matrix[i], &tmp);
        }

        bit1 = 0x1u - uint8_t_ith_coefficient(&matrix[row], col);
        // check if row-number_of_rows is 0, i.e. if row reached the end of the matrix
        bit2 = uint16_t_is_zero(row ^ number_of_rows);

        // increase if the pivot is 1 and row has not reached the end of the matrix
        row = row + ((uint16_t) ((uint16_t) ((uint16_t) (bit1 & bit2) ^ bit1) ^ bit2) ^ 0x1u);
    }

    return row;
}

// returns the rank of the matrix
int rank(bf_element_t *input_matrix, uint16_t number_of_rows) {

    uint8_t number_of_columns = ROLLO_I_FINITE_FIELD_DEGREE;
    uint8_t bit1, bit2;
    bf_element_t mask1, mask2, mask3, mask2_and_mask3, tmp;
    uint16_t col;
    uint16_t row = 0;
    uint16_t i;
    bf_element_t matrix[number_of_rows];
    for (i = 0; i < number_of_rows; ++i) {
        bf_copy(&matrix[i], &input_matrix[i]);
    }

    for (col = 0; col < number_of_columns; ++col) {
        for (i = 0; i < number_of_rows; ++i) {

            bf_compute_mask_inverse(&mask1, &matrix[row], col); // not is_zero(m[r,c])
            bf_compute_mask(&mask2, &matrix[i], col); // is_zero(m[i,c])
            bit1 = uint16_t_is_greater_than(i, row);
            bf_set_mask(&mask3, bit1);

            bf_and(&mask2_and_mask3, &mask2, &mask3);
            bf_and(&tmp, &mask2_and_mask3, &mask1);
            bf_and(&tmp, &matrix[i], &tmp);
            bf_addition(&matrix[row], &matrix[row], &tmp);

            bf_and(&tmp, &matrix[row], &mask2_and_mask3);
            bf_addition(&matrix[i], &matrix[i], &tmp);
        }

        bit1 = 0x1u - uint8_t_ith_coefficient(&matrix[row], col);
        // check if row-number_of_rows is 0, i.e. if row reached the end of the matrix
        bit2 = uint16_t_is_zero(row ^ number_of_rows);

        // increase if the pivot is 1 and row has not reached the end of the matrix
        row = row + ((uint16_t) ((uint16_t) ((uint16_t) (bit1 & bit2) ^ bit1) ^ bit2) ^ 0x1u);
    }

    return row;
}

int generate_random_support_basis(bf_element_t *support_basis, uint16_t rank, AES_XOF_struct *prng) {
    // The length of the support_basis must be rank

    bf_get_list_of_random_elements(prng, support_basis, rank);

    return EXIT_SUCCESS;
}

int generate_support_from_basis(bf_element_t *support, bf_element_t *support_basis, uint16_t support_basis_size) {
    bf_element_t accumulator;
    for (uint16_t i = 0; i < 1u << support_basis_size; ++i) {
        bf_set_to_zero(&accumulator);
        for (uint16_t j = 0; j < support_basis_size; j++) {
            if (((uint16_t) (i >> j) & 0x1u) == 1) {
                bf_addition(&accumulator, &accumulator, &support_basis[j]);
            }
        }
        bf_copy(&support[i], &accumulator);
    }

    return EXIT_SUCCESS;
}

int generate_random_linear_combination(bf_element_t *output, bf_element_t *basis, u_int16_t basis_length,
                                       AES_XOF_struct *prng) {
    bf_element_t mask;
    unsigned int bytes_to_generate_per_component = (basis_length + 7u) / 8;
    uint16_t random_combination_coefficients;

    randombytes((uint8_t *) &random_combination_coefficients, bytes_to_generate_per_component);
//        seedexpander(prng, &random_combination_coefficients, bytes_to_generate_per_component);

    bf_set_to_zero(output);
    for (uint16_t j = 0; j < basis_length; j++) {
        bf_set_mask(&mask, (uint16_t) (random_combination_coefficients >> j) & 0x1u);
        bf_and(&mask, &mask, &basis[j]);
        bf_addition(output, output, &mask);
    }

    return EXIT_SUCCESS;
}

int generate_random_linear_combinations(bf_element_t *output, uint16_t output_length, bf_element_t *basis,
                                        u_int16_t basis_length,
                                        AES_XOF_struct *prng) {
    bf_element_t mask;
    unsigned int bytes_to_generate_per_component = (basis_length + 7u) / 8;
    uint16_t random_combination_coefficients[output_length];
    // init array
    for (uint16_t i = 0; i < output_length; ++i) {
        random_combination_coefficients[i] = 0;
    }

    randombytes((uint8_t *) &random_combination_coefficients, output_length * bytes_to_generate_per_component);
//        seedexpander(prng, &random_combination_coefficients, bytes_to_generate_for_all_components);

    for (uint16_t i = 0; i < output_length; ++i) {
        bf_set_to_zero(&output[i]);
        for (uint16_t j = 0; j < basis_length; j++) {
            bf_set_mask(&mask, (uint16_t) (random_combination_coefficients[i] >> j) & 0x1u);
            bf_and(&mask, &mask, &basis[j]);
            bf_addition(&output[i], &output[i], &mask);
        }
    }

    return EXIT_SUCCESS;
}


int generate_list_of_vectors_with_given_rank(bf_element_t *list, uint16_t list_length, u_int16_t desired_rank,
                                             bf_element_t *list_basis, AES_XOF_struct *prng) {
    // rank is also the list basis length
    uint16_t actual_rank = 0;
    bf_element_t tmp_list[list_length];
    bf_element_t mask;

    for (uint8_t count = 0; count < 2; ++count) {
        generate_random_support_basis(list_basis, desired_rank, prng);
        generate_random_linear_combinations(tmp_list, list_length, list_basis, desired_rank, prng);

        bf_set_mask(&mask, uint16_t_is_zero(desired_rank - rank(tmp_list, list_length)));
        for (uint16_t j = 0; j < list_length; j++) {
            bf_and(&list[j], &mask, &tmp_list[j]);
        }
    }
    return EXIT_SUCCESS;
}

#if 1

int generate_two_list_of_vectors_with_given_rank_and_their_basis(
        // this function performs the cycle twice with no aborts,
        // as the probability of failing is 2^-120
        bf_element_t *list1, uint16_t list1_length,
        bf_element_t *list2, uint16_t list2_length,
        u_int16_t desired_rank, bf_element_t *list_basis, // TODO invert position of list basis and rank
        AES_XOF_struct *prng) {
    // rank is also the list basis length
    uint16_t actual_rank = 0;
    bf_element_t tmp_list[list1_length];
    bf_element_t mask;

    for (uint8_t count = 0; count < 2; ++count) {
        generate_random_support_basis(list_basis, desired_rank, prng);

        // generate list 1
        generate_random_linear_combinations(tmp_list, list1_length, list_basis, desired_rank, prng);
//        for (uint16_t i = 0; i < list1_length; ++i) {
//            generate_random_linear_combination(&tmp_list[i], list_basis, rank, prng);
//        }

        // TODO: currently this copy step is needed
        //  since the gaussian elimination reduces the matrix to row echelon form
        //  maybe it can be avoided
        for (uint16_t j = 0; j < list1_length; j++) {
            bf_copy(&list1[j], &tmp_list[j]);
        }

        actual_rank = to_row_echelon_form(list1, list1_length);

        bf_set_mask(&mask, uint16_t_is_zero(actual_rank - desired_rank));
        for (uint16_t j = 0; j < list1_length; j++) {
            bf_and(&list1[j], &mask, &tmp_list[j]);
        }

        // generate list 2
        generate_random_linear_combinations(tmp_list, list2_length, list_basis, desired_rank, prng);
//        for (uint16_t i = 0; i < list1_length; ++i) {
//            generate_random_linear_combination(&tmp_list[i], list_basis, rank, prng);
//        }

        // TODO: currently this copy step is needed
        //  since the gaussian elimination reduces the matrix to row echelon form
        //  maybe it can be avoided
        for (uint16_t j = 0; j < list2_length; j++) {
            bf_copy(&list2[j], &tmp_list[j]);
        }

        actual_rank = to_row_echelon_form(list2, list2_length);

        bf_set_mask(&mask, uint16_t_is_zero(actual_rank - desired_rank));
        for (uint16_t j = 0; j < list2_length; j++) {
            bf_and(&list2[j], &mask, &tmp_list[j]);
        }
    }
    return EXIT_SUCCESS;
}

#else

int generate_two_list_of_vectors_with_given_rank(
        // this function performs the cycle once with possibly an aborts,
        // as the probability of failing is 2^-60
        bf_element_t *list1, uint16_t list1_length,
        bf_element_t *list2, uint16_t list2_length,
        u_int16_t desired_rank, bf_element_t *list_basis, // TODO invert position of list basis and rank
        AES_XOF_struct *prng) {
    // desired_rank is also the list basis length

    generate_random_support_basis(list_basis, desired_rank, prng);

    // generate list 1
    generate_random_linear_combinations(list1, list1_length, list_basis, desired_rank, prng);
//    for (uint16_t i = 0; i < list1_length; ++i) {
//        generate_random_linear_combination(&list1[i], list_basis, desired_rank, prng);
//    }

    // abort
//    if (rank(list1, list1_length) != desired_rank)
//        return EXIT_FAILURE;

    // generate list 2
    generate_random_linear_combinations(list2, list2_length, list_basis, desired_rank, prng);
//    for (uint16_t i = 0; i < list2_length; ++i) {
//        generate_random_linear_combination(&list2[i], list_basis, desired_rank, prng);
//    }

    // abort
//    if (rank(list2, list1_length) != desired_rank)
//        return EXIT_FAILURE;

    return EXIT_SUCCESS;
}

#endif

// generate vector space of dimension "rank"
// todo: remove list_length (since it depends from rank)
// todo: unit test this function
// max rank that can be generated is ROLLO_I_ERROR_VECTORS_RANK_WEIGHT
int generate_list_of_vectors_with_given_rank2(bf_element_t *list, uint16_t list_length,
                                              u_int16_t rank, bf_element_t *list_basis, AES_XOF_struct *prng) {
    // The length of the list must be 2^rank
    // list_basis is the basis of the vector space

    bf_set_to_zero(&list[0]);

    size_t j;
//    while (1) {
//    uint8_t is_of_good_rank = 1;
    for (uint16_t i = 0; i < rank; i++) {

        bf_element_t random_value;
        bf_get_random_element(prng, &random_value);
        bf_copy(&list[1u << i], &random_value);

//        for (j = 0; j < 1u << i; j++) {
//                if (bf_is_equal(&random_value, &list[j])) {
//                    is_of_good_rank = 0;
//                }
//            is_of_good_rank = 1 - bf_is_equal(&random_value, &list[j]);
//        }
//            if (is_of_good_rank == 0) {
//                break;
//            }
        for (j = 1; j < (1u << i); j++) {
            bf_addition(&list[j + (1u << i)], &list[j], &random_value);
        }
        bf_copy(&list_basis[i], &random_value);
    }
//
//        if (is_of_good_rank) {
//            break;
//        }
//    }

    return EXIT_SUCCESS;
}


// reduces the matrix to row echelon form using gaussian elimination
// returns the rank of the matrix
// I performs gaussian elimination on the unified matrix:
// matrix_A||matrix_A
// 00.....0||matrix_B
// creating a right-top to left-down diagonal starting from matrix_A
int
zassenhaus_algorithm_reduction(bf_element_t *matrix_left, bf_element_t *matrix_right, uint16_t number_of_rows) {

    uint8_t bit1, bit2;
    bf_element_t mask1L, mask2L, mask3L, mask2_and_mask3L, tmpL;
    bf_element_t mask1R, mask2R, mask3R, mask2_and_mask3R, tmpR;
    uint16_t col;
    uint16_t row = 0;
    uint16_t i;

    // work on RIGHT part
    for (col = 0; col < ROLLO_I_FINITE_FIELD_DEGREE; ++col) {
        for (i = 0; i < number_of_rows; ++i) {

            bf_compute_mask_inverse(&mask1R, &matrix_right[row], col); // not is_zero(m[r,c])
            bf_copy(&mask1L, &mask1R);

            bf_compute_mask(&mask2R, &matrix_right[i], col); // is_zero(m[i,c])
            bf_copy(&mask2L, &mask2R);

            bit1 = uint16_t_is_greater_than(i, row);
            bf_set_mask(&mask3R, bit1);
            bf_copy(&mask3L, &mask3R);

            bf_and(&mask2_and_mask3R, &mask2R, &mask3R);
            bf_copy(&mask2_and_mask3L, &mask2_and_mask3R);

            bf_and(&tmpR, &mask2_and_mask3R, &mask1R);
            bf_copy(&tmpL, &tmpR);

            bf_and(&tmpR, &matrix_right[i], &tmpR);
            bf_and(&tmpL, &matrix_left[i], &tmpL);

            bf_addition(&matrix_right[row], &matrix_right[row], &tmpR);
            bf_addition(&matrix_left[row], &matrix_left[row], &tmpL);

            bf_and(&tmpR, &matrix_right[row], &mask2_and_mask3R);
            bf_and(&tmpL, &matrix_left[row], &mask2_and_mask3L);

            bf_addition(&matrix_right[i], &matrix_right[i], &tmpR);
            bf_addition(&matrix_left[i], &matrix_left[i], &tmpL);
        }

        bit1 = 0x1u - uint8_t_ith_coefficient(&matrix_right[row], col);
        // check if row-number_of_rows is 0, i.e. if row reached the end of the matrix
        bit2 = uint16_t_is_zero(row ^ number_of_rows);

        // increase if the pivot is 1 and row has not reached the end of the matrix
        row = row + ((uint16_t) ((uint16_t) ((uint16_t) (bit1 & bit2) ^ bit1) ^ bit2) ^ 0x1u);
    }
    // work on LEFT part
    for (col = 0; col < ROLLO_I_FINITE_FIELD_DEGREE; ++col) {
        for (i = 0; i < number_of_rows; ++i) {

            bf_compute_mask_inverse(&mask1L, &matrix_left[row], col); // not is_zero(m[r,c])
            bf_copy(&mask1R, &mask1L);

            bf_compute_mask(&mask2L, &matrix_left[i], col); // is_zero(m[i,c])
            bf_copy(&mask2R, &mask2L);

            bit1 = uint16_t_is_greater_than(i, row);
            bf_set_mask(&mask3L, bit1);
            bf_copy(&mask3R, &mask3L);

            bf_and(&mask2_and_mask3L, &mask2L, &mask3L);
            bf_copy(&mask2_and_mask3R, &mask2_and_mask3L);

            bf_and(&tmpL, &mask2_and_mask3L, &mask1L);
            bf_copy(&tmpR, &tmpL);

            bf_and(&tmpL, &matrix_left[i], &tmpL);
            bf_and(&tmpR, &matrix_right[i], &tmpR);

            bf_addition(&matrix_left[row], &matrix_left[row], &tmpL);
            bf_addition(&matrix_right[row], &matrix_right[row], &tmpR);

            bf_and(&tmpL, &matrix_left[row], &mask2_and_mask3L);
            bf_and(&tmpR, &matrix_right[row], &mask2_and_mask3R);

            bf_addition(&matrix_left[i], &matrix_left[i], &tmpL);
            bf_addition(&matrix_right[i], &matrix_right[i], &tmpR);
        }

        bit1 = 0x1u - uint8_t_ith_coefficient(&matrix_left[row], col);
        // check if row-number_of_rows is 0, i.e. if row reached the end of the matrix
        bit2 = uint16_t_is_zero(row ^ number_of_rows);

        // increase if the pivot is 1 and row has not reached the end of the matrix
        row = row + ((uint16_t) ((uint16_t) ((uint16_t) (bit1 & bit2) ^ bit1) ^ bit2) ^ 0x1u);
    }

    return row;
}

int zassenhaus_fill_initial_matrix(bf_element_t *zassenhaus_matrix_left,
                                   bf_element_t *zassenhaus_matrix_right,

                                   bf_element_t *S1, size_t S1_length,
                                   bf_element_t *S2, size_t S2_length) {

    size_t zassenhaus_matrix_length = S1_length + S2_length;
    size_t l;

    // fill with zeros
    for (l = 0; l < zassenhaus_matrix_length; ++l) {
        bf_set_to_zero(&zassenhaus_matrix_left[l]);
        bf_set_to_zero(&zassenhaus_matrix_right[l]);
    }

    // fill upper part of the matrix
    for (l = 0; l < S1_length; ++l) {
        bf_copy(&zassenhaus_matrix_left[l], &S1[l]);
        bf_copy(&zassenhaus_matrix_right[l], &S1[l]);
    }
    // fill lower part of the matrix
    for (l = 0; l < S2_length; ++l) {
        bf_copy(&zassenhaus_matrix_right[l + S1_length], &S2[l]);
        bf_set_to_zero(&zassenhaus_matrix_left[l + S1_length]);
    }

    return EXIT_SUCCESS;
}

// returns S1^S2 if output_selection = 2
int zassenhaus_algorithm_intersection(bf_element_t *output, size_t output_length,
                                      bf_element_t *S1, size_t S1_length,
                                      bf_element_t *S2, size_t S2_length) {
    size_t k;

    uint8_t is_zero;
    uint8_t intersection_dimension;
    bf_element_t mask;

    size_t zassenhaus_matrix_length = S1_length + S2_length;
    bf_element_t zassenhaus_matrix_left[zassenhaus_matrix_length];
    bf_element_t zassenhaus_matrix_right[zassenhaus_matrix_length];

    zassenhaus_fill_initial_matrix(zassenhaus_matrix_left,
                                   zassenhaus_matrix_right,
                                   S1, S1_length,
                                   S2, S2_length);
    uint8_t verb = 0;

    if (verb) {
        uint32_t i;
        printf("\nCOMPUTING INTERSECTION...\n");
        printf("\nINPUT\n");
        printf("len(S1) = %lu\n", S1_length);
        printf("len(S2) = %lu\n", S2_length);
        for (i = 0; i < zassenhaus_matrix_length; ++i) {
            printf("%3d ", i);
            bf_print_binary(&zassenhaus_matrix_left[i]);
            printf(" ");
            bf_print_binary(&zassenhaus_matrix_right[i]);
            printf("\n");
            if (i == S1_length - 1)
                printf("\n");
        }
    }

    zassenhaus_algorithm_reduction(zassenhaus_matrix_left, zassenhaus_matrix_right, zassenhaus_matrix_length);

    if (verb) {
        uint32_t i;
        printf("\nOUTPUT\n");
        printf("len(S1) = %lu\n", S1_length);
        printf("len(S2) = %lu\n", S2_length);
        for (i = 0; i < zassenhaus_matrix_length; ++i) {
            printf("%3d ", i);
            bf_print_binary(&zassenhaus_matrix_left[i]);
            printf(" ");
            bf_print_binary(&zassenhaus_matrix_right[i]);
            printf("\n");
            if (i == S1_length - 1)
                printf("\n");
        }
    }

    for (k = 0; k < output_length; ++k) {
        bf_set_to_zero(&output[k]);
    }

    intersection_dimension = 0;
    for (k = 0; k < zassenhaus_matrix_length; ++k) {
        is_zero = bf_is_zero(&zassenhaus_matrix_right[zassenhaus_matrix_length - k - 1]);
        is_zero = is_zero & (1 - bf_is_zero(&zassenhaus_matrix_left[zassenhaus_matrix_length - k - 1]));
        bf_set_mask(&mask, is_zero);
        bf_and(&mask, &zassenhaus_matrix_left[zassenhaus_matrix_length - k - 1], &mask);
        bf_copy(&output[intersection_dimension], &mask);
        intersection_dimension = intersection_dimension + is_zero;
    }

    return intersection_dimension;
}

// returns S1+S2 if output_selection = 2
int zassenhaus_algorithm_sum(bf_element_t *output, size_t output_length,
                             bf_element_t *S1, size_t S1_length,
                             bf_element_t *S2, size_t S2_length) {
    size_t k;

    uint8_t checking_bit;
    uint8_t sum_dimension;
    bf_element_t mask;

    size_t zassenhaus_matrix_length = S1_length + S2_length;
    bf_element_t zassenhaus_matrix_left[zassenhaus_matrix_length];
    bf_element_t zassenhaus_matrix_right[zassenhaus_matrix_length];

    zassenhaus_fill_initial_matrix(zassenhaus_matrix_left,
                                   zassenhaus_matrix_right,
                                   S1, S1_length,
                                   S2, S2_length);
    uint8_t verb = 0;

    if (verb) {
        uint32_t i;
        printf("\nCOMPUTING SUM...\n");
        printf("\nINPUT\n");
        printf("len(S1) = %lu\n", S1_length);
        printf("len(S2) = %lu\n", S2_length);
        for (i = 0; i < zassenhaus_matrix_length; ++i) {
            printf("%3d ", i);
            bf_print_binary(&zassenhaus_matrix_left[i]);
            printf(" ");
            bf_print_binary(&zassenhaus_matrix_right[i]);
            printf("\n");
            if (i == S1_length - 1)
                printf("\n");
        }
    }

    zassenhaus_algorithm_reduction(zassenhaus_matrix_left, zassenhaus_matrix_right, zassenhaus_matrix_length);

    if (verb) {
        uint32_t i;
        printf("\nOUTPUT\n");
        printf("len(S1) = %lu\n", S1_length);
        printf("len(S2) = %lu\n", S2_length);
        for (i = 0; i < zassenhaus_matrix_length; ++i) {
            printf("%3d ", i);
            bf_print_binary(&zassenhaus_matrix_left[i]);
            printf(" ");
            bf_print_binary(&zassenhaus_matrix_right[i]);
            printf("\n");
            if (i == S1_length - 1)
                printf("\n");
        }
    }

    for (k = 0; k < output_length; ++k) {
        bf_set_to_zero(&output[k]);
    }

    sum_dimension = 0;
    for (k = 0; k < zassenhaus_matrix_length; ++k) {
        checking_bit = (1 - bf_is_zero(&zassenhaus_matrix_right[zassenhaus_matrix_length - k - 1]));
        bf_set_mask(&mask, checking_bit);
        bf_and(&mask, &zassenhaus_matrix_right[zassenhaus_matrix_length - k - 1], &mask);
        bf_copy(&output[sum_dimension], &mask);
        sum_dimension = sum_dimension + checking_bit;
    }

    return sum_dimension;
}


int sort_list_of_vectors(bf_element_t *list, uint16_t list_length) {
    uint32_t i, j;
    uint8_t checking_bit;
    bf_element_t mask, mask_inverse, tmp_err_supp1, tmp_err_supp2, tmp_err_supp3, tmp_err_supp4;

    for (i = 0; i < list_length - 1; i++) {
        for (j = 0; j < list_length - i - 1; j++) {

            // swap error_support[j+1] and error_support[j] if error_support[j] > error_support[j+1]
            checking_bit = bf_greater_than(&list[j], &list[j + 1]);
            bf_set_mask(&mask, checking_bit);
            bf_set_mask(&mask_inverse, 1 - checking_bit);

            bf_and(&tmp_err_supp1, &list[j], &mask);
            bf_and(&tmp_err_supp2, &list[j + 1], &mask_inverse);
            bf_and(&tmp_err_supp3, &list[j], &mask_inverse);
            bf_and(&tmp_err_supp4, &list[j + 1], &mask);

            bf_addition(&list[j + 1], &tmp_err_supp1, &tmp_err_supp2);
            bf_addition(&list[j], &tmp_err_supp3, &tmp_err_supp4);
        }
    }

    return EXIT_SUCCESS;
}

// Given
// - the base of the vector subspace F of GF(2^m),
// - the syndrome S (a list of n vectors)
//   S is supposed to be EF (not only a subspace of EF), generated by s = (s_0, ..., s_n-1),
//   such that He = s
// - the dimension of E i.e. r (implicit)
// Returns
// - (probably) E, i.e. the support of the error.
//   e should have been generated by r elements.
int rank_support_recover(bf_element_t *subspaceE_basis, bf_element_t *subspaceF_basis, polynomial_t s) {

    bf_element_t F_to_the_minus_one[ROLLO_I_KEY_VECTORS_RANK_WEIGHT];
    size_t i, j;
    size_t product_space_dimension = ROLLO_I_KEY_VECTORS_RANK_WEIGHT * ROLLO_I_ERROR_VECTORS_RANK_WEIGHT;
    size_t zassenhaus_submatrix_length = product_space_dimension;
    uint16_t dimension_zassenhaus_output;
    bf_element_t tmpFS[product_space_dimension];
    bf_element_t matrix_left_high_tmp[product_space_dimension];

    uint8_t verb = 0;

    // Part 1: Compute a basis of S of dimension rd to work on
    to_row_echelon_form(&s.coefficients, ROLLO_I_CODE_LENGTH);

    // Part 2: Recover the vector space E

    // Part 2 - Step 1
    if (verb) {
        printf("\nF = <f_1, ..., f_d>\n");
        for (i = 0; i < ROLLO_I_KEY_VECTORS_RANK_WEIGHT; ++i) {
            bf_inversion(&F_to_the_minus_one[i], &subspaceF_basis[i]);
            printf("\nF[%lu]^-1 = ", i);
            bf_print_binary(&F_to_the_minus_one[i]);
        }
    }

    if (verb) {
        bf_element_t tmppp[product_space_dimension];

        printf("\nSupport of the syndrome:\n");
        for (i = 0; i < product_space_dimension; ++i) {
            printf("\ns.coefficients[%lu] = ", i);
            bf_print_binary(&s.coefficients[i]);
            bf_copy(&tmppp[i], &s.coefficients[i]);
        }
        printf("\nDimension = %d\n", to_row_echelon_form(tmppp, product_space_dimension));
    }

    bf_inversion(&F_to_the_minus_one[0], &subspaceF_basis[0]);
    for (j = 0; j < product_space_dimension; ++j) {
        bf_multiplication(&matrix_left_high_tmp[j], &F_to_the_minus_one[0], &s.coefficients[j]);
    }

    for (i = 1; i < ROLLO_I_KEY_VECTORS_RANK_WEIGHT; ++i) {
        for (j = 0; j < product_space_dimension; ++j) {
            bf_inversion(&F_to_the_minus_one[i], &subspaceF_basis[i]);
            bf_multiplication(&tmpFS[j], &F_to_the_minus_one[i], &s.coefficients[j]);
        }
        dimension_zassenhaus_output = zassenhaus_algorithm_intersection(
                matrix_left_high_tmp, zassenhaus_submatrix_length,
                matrix_left_high_tmp, zassenhaus_submatrix_length,
                tmpFS, zassenhaus_submatrix_length);

        if (verb) {
            printf("\n\nDimension = %d\n", dimension_zassenhaus_output);
            printf("T ^ D[%lu] = \n", i);
            for (size_t ii = 0; ii < zassenhaus_submatrix_length; ++ii) {
                printf("%3lu ", ii);
                bf_print_binary(&matrix_left_high_tmp[ii]);
                printf("\n");
            }
        }
    }

    // Part 2 - Step 2
    // reduce basis to reduce row echelon form
    to_reduced_row_echelon_form(matrix_left_high_tmp, ROLLO_I_ERROR_VECTORS_RANK_WEIGHT);
    if (verb) {
        printf("\n");
        bf_print_matrix_bin(matrix_left_high_tmp, ROLLO_I_ERROR_VECTORS_RANK_WEIGHT);
    }

    for (i = 0; i < ROLLO_I_ERROR_VECTORS_RANK_WEIGHT; ++i) {
        bf_copy(&subspaceE_basis[i], &matrix_left_high_tmp[i]);
    }

    return EXIT_SUCCESS;
}
